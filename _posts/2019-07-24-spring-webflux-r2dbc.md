---
layout: post
title: Spring WebFlux and Spring Data R2DBC
date: 2019-07-24
tags: [spring framework, spring webflux, reactive, spring data, r2dbc]
---

In the last [guide][spring-webflux.post] we build a reactive web application using Spring WebFlux.

That application used a H2 relational database for persisting data. We used a `spring-data-jpa` library to give us the necessary primitives to handle calls to the database.
Unfortunately, this library uses standard JDBC driver, which is inherently blocking.
While functionally the solution works, it required us to block execution in our handler functions, which is not ideal.

In this guide, we will address this limitation by replacing the JDBC library with one that supports reactive database connections (i.e. [R2DBC][r2dbc.git]).

The code for this guide is available in [GitHub][spring-webflux-r2dbc.git].

### Create a new project
While we could start with the existing [code base][spring-webflux.git], there are sufficient differences between the two implementations that warrant a fresh start.

Create a new Spring Boot project using Gradle (v5.5.x).

```bash
~$ mkdir spring-webflux-r2dbc && cd spring-webflux-r2dbc
~$ gradle init --project-name spring-webflux-r2dbc --type java-application --test-framework junit-jupiter --package spring.webflux.r2dbc.example --dsl groovy
```

Replace the contents of the `build.gradle` file with the following:

```groovy
plugins {
  id 'java'
    id 'idea'
    id 'org.springframework.boot' version '2.2.0.M4'
}

repositories {
  jcenter()
    maven {
      url 'https://repo.spring.io/milestone'
    }
}

dependencies {
  implementation 'org.springframework.boot:spring-boot-starter-webflux:2.2.0.M4'
    implementation 'org.springframework.boot.experimental:spring-boot-starter-data-r2dbc:0.1.0.M1'
    implementation 'org.springframework.boot.experimental:spring-boot-starter-r2dbc-h2:0.1.0.M1'

    testImplementation 'org.junit.jupiter:junit-jupiter:5.5.0'
    testImplementation 'org.junit.platform:junit-platform-commons:1.5.0'
    testImplementation 'org.junit.platform:junit-platform-launcher:1.5.0'

    testImplementation('org.springframework.boot:spring-boot-starter-test:2.2.0.M4') {
      exclude group: 'junit'
    }

  testImplementation 'io.projectreactor:reactor-test:3.3.0.M2'
}

test {
  useJUnitPlatform()
}
```

Reactive database connectivity in Spring is relatively new and Spring Boot is still catching up.
To make things work, we had to rely on the milestone releases of the Spring Boot gradle plugin as well as the starter modules for both Spring WebFlux and Spring Data R2DBC.

### Spring Boot Application
Let's convert the vanila Java application auto-generated by the `gradle` script into a Spring Boot web application.
Replace the contents of the `App.java` class file with the following:

  ```java
package spring.webflux.r2dbc.example;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class App {

    public static void main(String[] args) {
      SpringApplication.run(App.class, args);
    }
}
```

### Create microservice

Let's begin with the entity model.

```java
package spring.webflux.r2dbc.example.message;

import org.springframework.data.annotation.Id;
import org.springframework.data.relational.core.mapping.Column;
import org.springframework.data.relational.core.mapping.Table;

@Table
public class Message {

  @Id
  private Long id;

  @Column
  private String text;

  private Message() {
    // default constructor is required by R2DBC data converter
  }

  private Message(Long id, String text) {
    this.id = id;
    this.text = text;
  }

  public Message(String text) {
    this(null, text);
  }

  public Long getId() {
    return id;
  }

  public String getText() {
    return text;
  }

  public Message updateMessageText(String text) {
    return new Message(this.getId(), text);
  }
}
```

The differences between this implementation and its JPA equivalent are subtle.
We have replaced the `@Entity` annotation with `@Table`, and the `@Id` and `@Column` annotations comes from a different package as well.

One notable omission is the `@GeneratedValue` annotation, which allowed us to control how primary keys are generated within the application code.
This is now delegated to the database.

Next, we can define a repository interface.
This time we can use the `ReactiveCrudRepository` interface instead of the `CrudRepository` (using the same code in the previous example would have caused a runtime exception).

```java
package spring.webflux.r2dbc.example.message;

import org.springframework.data.repository.reactive.ReactiveCrudRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface MessageRepository extends ReactiveCrudRepository<Message, Long> {
}
```

Finally, we need to write a database script to create the necessary table in our database.
For example, to create a SQL script to add the `message` table to the H2 database, add this `src/main/resources/schema.sql` with the following content to your project:

```sql
CREATE TABLE message (
   id BIGINT AUTO_INCREMENT PRIMARY KEY,
   text VARCHAR(255)
);
```

Since we're using an in-memory database, we will need to re-create this table everytime we start the application.
To ensure that this gets run, add the following to the `src/main/resources/application.yaml`:

```yaml
spring.r2dbc.initialization-mode: always
```

### Create HTTP Request Handler
The `MessageHandler` implementation is also subtly different.

Since the `MessageRepository` interface is reactive (i.e. all methods are defined to return either `Mono` or `Flux` objects),
we can now properly chain our calls without needing to resort to blocking execution to perform database calls.

This effectively makes the entire execution flow non-blocking!

```java
package spring.webflux.r2dbc.example.message;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import org.springframework.web.reactive.function.server.ServerRequest;
import org.springframework.web.reactive.function.server.ServerResponse;
import reactor.core.publisher.Mono;

import java.net.URI;

@Component
public class MessageHandler {

  @Autowired
    private MessageRepository messageRepo;

  public Mono<ServerResponse> get(ServerRequest req) {
    return Mono.justOrEmpty(req.pathVariable("id"))
      .map(Long::valueOf)
      .flatMap(messageRepo::findById)
      .flatMap(m -> ServerResponse.ok().syncBody(m))
      .switchIfEmpty(ServerResponse.notFound().build());
  }

  public Mono<ServerResponse> create(ServerRequest req) {
    return req.bodyToMono(Message.class)
      .flatMap(messageRepo::save)
      .flatMap(message -> ServerResponse.created(URI.create("/messages/" + message.getId())).syncBody(message));
  }

  public Mono<ServerResponse> update(ServerRequest req) {
    return req.bodyToMono(Message.class)
      .flatMap(messageRepo::save)
      .flatMap(message -> ServerResponse.ok().syncBody(message));
  }

  public Mono<ServerResponse> delete(ServerRequest req) {
    return Mono.justOrEmpty(req.pathVariable("id"))
      .map(Long::valueOf)
      .flatMap(messageRepo::deleteById)
      .flatMap(done -> ServerResponse.ok().build());
  }

}
```

### Create a router
The router remains exactly the same as in the previous example.
It is included here for completeness only.

```java
package spring.webflux.r2dbc.example.message;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.reactive.function.server.RouterFunction;
import org.springframework.web.reactive.function.server.ServerResponse;

import static org.springframework.http.MediaType.APPLICATION_JSON;
import static org.springframework.web.reactive.function.server.RequestPredicates.accept;
import static org.springframework.web.reactive.function.server.RouterFunctions.route;

@Configuration
public class MessageRouter {

  @Bean
    public RouterFunction<ServerResponse> routes(MessageHandler handler) {
      return route()
        .path("/messages", builder -> builder
            .GET("/{id}", handler::get)
            .POST("/", accept(APPLICATION_JSON), handler::create)
            .PUT("/{id}", accept(APPLICATION_JSON), handler::update)
            .DELETE("/{id}", accept(APPLICATION_JSON), handler::delete)
            ).build();
    }
}
```

### Testing
As you would expect there should not be many changes to our tests.
Since we kept the interface identical to the previous implementation everything should work as before.

The only minor difference being where we relied on the `MessageRepository` within our tests to initialise the database with test data.
Now we have to contend with the asynchronous nature of the interface.

```java
package spring.webflux.r2dbc.example.message;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.web.reactive.server.WebTestClient;
import reactor.test.StepVerifier;

import static java.lang.String.format;
import static org.springframework.boot.test.context.SpringBootTest.WebEnvironment.RANDOM_PORT;

@SpringBootTest(webEnvironment = RANDOM_PORT)
public class MessageEndpointIT {

    @Autowired
    private MessageRepository messageRepo;

    @Autowired
    private WebTestClient client;

    private Message message;

    @BeforeEach
    public void setUpDatabseWithDefaultMessage() {
        message = messageRepo.save(new Message("Hello World!")).block();
    }

    @Test
    public void testGetMessage() {
        var uri = format("/messages/%d", message.getId());
        client.get().uri(uri)
          .exchange()
          .expectStatus().isOk()
          .expectBody()
          .jsonPath("$.id").isEqualTo(message.getId())
          .jsonPath("$.text").isEqualTo("Hello World!");
    }

    @Test
    public void testGetMessageThatDoesNotExist() {
        client.get().uri("/messages/10001")
          .exchange()
          .expectStatus().isNotFound();
    }

    @Test
    public void testCreateMessage() {
        var message = new Message("Hello There!");
        client.post().uri("/messages")
          .syncBody(message)
          .exchange()
          .expectStatus().isCreated()
          .expectHeader().valueMatches("Location", "^/messages/\\d$")
          .expectBody()
          .jsonPath("$.id").isNumber()
          .jsonPath("$.text").isEqualTo("Hello There!");
    }

    @Test
    public void testUpdateMessage() {
        var uri = format("/messages/%d", message.getId());
        client.put().uri(uri)
          .syncBody(message.updateMessageText("Text Changed!"))
          .exchange()
          .expectStatus().isOk()
          .expectBody()
          .jsonPath("$.id").isEqualTo(message.getId())
          .jsonPath("$.text").isEqualTo("Text Changed!");
    }

    @Test
    public void testDeleteMessage() {
        // first check that the message exists in the database
        messageRepo.findById(message.getId())
          .as(StepVerifier::create)
          .expectNextCount(1)
          .verifyComplete();

        // call the API to delete it
        var uri = format("/messages/%d", message.getId());
        client.delete().uri(uri)
          .exchange()
          .expectStatus().isOk();

        // verify that the message was deleted from the database
        messageRepo.findById(message.getId())
          .as(StepVerifier::create)
          .expectNextCount(0)
          .verifyComplete();
    }
}
```

### Conclusion
In this guide, we addressed the limitation caused by our use of JPA/JDBC library by replacing it with its reactive alternative.

The complete, working solution is available in [GitHub][spring-webflux-r2dbc.git].


[r2dbc.git]: https://github.com/r2dbc
[spring-webflux.post]: /2019/07/18/spring-webflux
[spring-webflux.git]: https://github.com/academyhq/spring-webflux
[spring-webflux-r2dbc.git]: https://github.com/academyhq/spring-webflux-r2dbc
