---
layout: post
title: Building an OAuth 2 authorization server with Spring Boot
date: 2019-06-28
tags: [spring framework, spring boot, spring security, java, gradle, jwt, oauth]
---

This guide demonstrates how to build an OAuth 2 authorization server using Spring Boot 2 and Spring Security 5.
We will use JSON Web Token (JWT) standard to represent access tokens generated by this authorization server.
We shall make use of asymmetric key cryptography (specifically `RS256`) to digitally sign access tokens.

The code for this guide is available in [GitHub][spring-boot-oauth2-authorization-server.git].

### Create a new project
Create a new Spring Boot project using Gradle.

```bash
~$ mkdir spring-boot-oauth2-authorization-server && cd spring-boot-oauth2-authorization-server
~$ gradle init --project-name spring-boot-oauth2-authorization-server --type java-application --test-framework junit --package spring.boot.oauth2.authorization.server --dsl groovy
```

Replace the contents of the `build.gradle` file with the following:

```groovy
plugins {
  id 'java'
  id 'idea'
  id 'org.springframework.boot' version '2.1.4.RELEASE'
  id 'io.spring.dependency-management' version '1.0.7.RELEASE'
}

repositories {
  jcenter()
}

dependencies {
  implementation 'org.springframework.boot:spring-boot-starter-web'
  implementation 'org.springframework.boot:spring-boot-starter-security'
  implementation 'org.springframework.security.oauth.boot:spring-security-oauth2-autoconfigure:2.1.6.RELEASE'
  implementation 'org.glassfish.jaxb:jaxb-runtime'

  testImplementation('org.springframework.boot:spring-boot-starter-test') {
      exclude group: 'junit', module: 'junit'
  }
  testImplementation 'org.springframework.security:spring-security-test'
  testImplementation 'org.hamcrest:hamcrest:2.1'
  testImplementation 'org.junit.jupiter:junit-jupiter:5.4.2'
  testImplementation 'org.junit.platform:junit-platform-launcher:1.4.1'
}

sourceCompatibility = 11.0
targetCompatibility = 11.0

test {
  useJUnitPlatform()
}
```

### Spring Boot Application
Let's convert the vanila Java application auto-generated by the `gradle` script into a Spring Boot web application.
Replace the contents of the `App.java` class file with the following:

```java
package spring.boot.oauth2.authorization.server;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.security.oauth2.config.annotation.web.configuration.EnableAuthorizationServer;

@SpringBootApplication
@EnableAuthorizationServer
public class App {
    public static void main(String[] args) {
        SpringApplication.run(App.class, args);
    }
}
```

We declare the above class to be both a Spring Boot application (using the `@SpringBootApplication` annotation),
as well as an OAuth authorization server (using the `@EnableAuthorizationServer` annotation).

### Configure Authorization Server
Since we want our authorization server to create JWT tokens signed using `RS256` algorithm, we need to generate a private signing key and configure our application.
You can use OpenSSL to generate the signing and verifier keys. For example, to generate a 2048 bit RSA key pair do the following:

```bash
~$ openssl genrsa -out signing-key.pem 2048
~$ openssl rsa -in signing-key.pem -pubout -out verifier-key.pem
```

Copy the contents of the `signing-key.pem` file into the `src/main/resources/application.yaml` file using the `security.oauth2.authorization.jwt.key-value` property.

> **Warning**
> We are adding the signing key to our application properties file for demonstration purposes only.
> Storing unencrypted private keys or committing them to Git is a bad idea.

You will also have to configure a client. This is the application that will be making calls to the resource server on behalf of your users.
At the minimum, this client needs to be issued with a client identifier and an authentication secret.
The client application will use these credentials to access protected resources of the authorization server.

```yaml
security:
  oauth2:
    client:
      client-id: client
      client-secret: password
    authorization:
      jwt:
        key-value: |
          -----BEGIN RSA PRIVATE KEY-----
          MIIEowIBAAKCAQEA1vHuOHqm8nI8A1EulAyABIr1JyIxy2eGKVpbDD8PX2Az0MHU
          auIGc1fKuXtpy/QxAun6DEP1Rcf91i4AhnWXaaGqKmVvepHc6g8DWGaS+2xwiyh2
          iidSLL2jdJPjFe6w7sH/E7s/TfA+vuT2HQqUgGpqoJI1Bhinmf0PPiHJ8VeD0rn1
          DK7dkc99m6YyEiHWXMHbXPUt4M+XDvx+GGyvVJy2RNIcUBf3rUfn64fFWKPxoC64
          dVmC+9KTXY1JiCwKCqns2LQg0aAQUqdb8Q6PDzqN69TbTloSfgj3CGHhAfK7tuJb
          SF8xVBu3H3dhS3HC1y0dZVMMr/6aPNdwUOo/2wIDAQABAoIBAGQ0y6NHAve6a+H8
          AeQBY9k6UwoYdfBm5fP3bMTrzSXguqdTBc2CbBFv11HbiDoOMJ80J196eyk6EEu+
          jH4i6iDTvnofafZRdBUmRJ/8yf8u0dT+Wy0TIcs76a0amN6Lta7JgDpZrCyQmR/z
          rA1j9lFbyzPqlY+vBMvUXzvPEs9Q66mwfdMyaP6AJGStnv+5T7LTAN3oYqgy2oJk
          CITOS5hiUt7Hxv60Nc0DCqd0pLQd3r04MHX56WJGPI42eGpfv7bZe1nU20l4tEag
          Y+8uiJf1mGpxFi4UdHQiLEIyY4+poZbSAK35DiT+FKToidziciknULY0FvAGuwdj
          lPI6xyECgYEA6/VkODPiyzIHlnbVdh5Yu+8O89w9T8+zMYJcNBMsXNYUcnSMUqvz
          nZXanx/8GAsn5wE0ajI3bXcgV0ZNr3Ni5/0vBbb1D1oNcjIhoKf6lRd5KosfkpP6
          imNxee+8RGZjRzVklvTZnyg+YsVqPB7+4i1q4gHCzeDV8w8LUhssl+sCgYEA6TOg
          swEY/QI85ewIFFRxFoGNCMr4Q0dikn/+no5wtPlVeFCU1f75ypWjqoWwOWy7o28v
          aetnMs0NElXHotrtmOCAJ5zynTc5FUN7XLmYGLbTbL67VBR7lGYuR7YY8vfnBUwp
          wYtvrzIFasg5R1j4to3g0OfeIDmurD0eAIRJa9ECgYBn9SOEh4eiUpZ5Oj3t3ozl
          r/t8gUoaAb5HT9Hjt5bSCBfWHXc9bTjV8xHxDZx502BvLF61cw5skhGTogvUAxhO
          cYPoFqV9cAWAjIm4SInkagUeM1FjuQKnOgzi1jayRBH1a5a304SV1Js31RZrCpTt
          fWkbzf7PygE5JyWrtQE+pQKBgQCZaO45c+plXtiDBLAX96jhfl4yP5vsXoSZDXyJ
          //hjBXdVi+Utlevrel9NqV7RmBckH9uYGVUtVTlZK3cGSnFtVZrY9GWiSRbTRy5b
          RHirIXKaoiqH2GWnrUSaxk9JXw3qLT125myVWxm3MnqD1iLfrRwNMcutdWTUR+x5
          uIy4UQKBgDrmpCyYm1lU7tG+7k/FUlMcxw6IGJnWX4Gg9lkfFrVB2PU0f49RvB+f
          0P7RRPywzWxsLfqHRQ3UDhfKow5H0n34SaXjqjp6aB9y2po7nf+B7kP0w0m80pkn
          6dbbE+dxhvJPTcdO3mGTf8/Rn2qCKbiHUbHfXROb5yn3eiUXFFkY
          -----END RSA PRIVATE KEY-----
```

### Quick Test

We can quickly test that we now have a fully functioning authorization server. Start the application server using this Spring Boot gradle command:

```bash
~$ ./gradlew bootRun
```

Once the application starts, we can test the `/oauth/token` endpoint using the `curl` command, e.g.

```bash
~$ curl -X POST client:password@localhost:8080/oauth/token -dgrant_type=client_credentials -dscope=any
```
(**Note**: By default all grant types are enabled, `client_credentials` is the simplest one to use for a quick test).

The response should look something like this:

```json
{
  "access_token": "JWT ACCESS TOKEN GOES HERE",
  "token_type": "bearer",
  "expires_in": 43199,
  "scope": "any",
  "jti": "d3faa1c7-9c8a-462d-9b1a-35157f2f1da3"
}
```

A quick way to check the contents of the JWT token is to use the excellent [https://jwt.io/](https://jwt.io/) online tool.

### Re-Configure Authoriztion Server

This implementation works as described but there are some disadventages that quickly make this approach too simplistic for any practical application.
For example, it only allows for *one* client to be configured within the authorization server and only at start time.
Realistically, you may want to allow clients to dynamically register with your server and issue them with client credentials as part of your self-service on-baording process.

Also, all auto-configured OAuth endpoints are by default protected but it is likely that you may want some of those public.
For example, `/oauth/token_key` is an endpoint that returns the authorization server's public key, which can be used by resource servers to verify access token signatures.
It is safe to expose this endpoint to your clients but to do so we need to take over the auto-configuration of the authorization server.

This can be done by defining a custom configuration class (annotated with `@Configuration`) and extending it with `AuthorizationServerConfigurerAdapter` class.
Unfortunately, once you do this, some of the configurations you got for free will be disabled. For example, the JWT converter and the signing key will have to be manually configured.
Otherwise, the implementation will default to UUID-based, opaque tokens.

```java
package spring.boot.oauth2.authorization.server;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.autoconfigure.security.oauth2.authserver.AuthorizationServerProperties;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.oauth2.config.annotation.configurers.ClientDetailsServiceConfigurer;
import org.springframework.security.oauth2.config.annotation.web.configuration.AuthorizationServerConfigurerAdapter;
import org.springframework.security.oauth2.config.annotation.web.configuration.EnableAuthorizationServer;
import org.springframework.security.oauth2.config.annotation.web.configurers.AuthorizationServerEndpointsConfigurer;
import org.springframework.security.oauth2.config.annotation.web.configurers.AuthorizationServerSecurityConfigurer;
import org.springframework.security.oauth2.provider.token.store.JwtAccessTokenConverter;

@Configuration
@EnableAuthorizationServer
@EnableConfigurationProperties(AuthorizationServerProperties.class)
public class AuthorizationServerConfigurer extends AuthorizationServerConfigurerAdapter {

    @Autowired
    private AuthorizationServerProperties properties;

    @Override
    public void configure(AuthorizationServerSecurityConfigurer security) throws Exception {
        security.tokenKeyAccess("permitAll()");
    }

    @Override
    public void configure(ClientDetailsServiceConfigurer clients) throws Exception {
        clients.inMemory()
                .withClient("client")
                .secret(passwordEncoder().encode("password"))
                .authorizedGrantTypes("client_credentials");
    }

    @Override
    public void configure(AuthorizationServerEndpointsConfigurer endpoints) {
        endpoints.accessTokenConverter(accessTokenConverter());
    }

    @Bean
    public JwtAccessTokenConverter accessTokenConverter() {
        var converter = new JwtAccessTokenConverter();
        converter.setSigningKey(properties.getJwt().getKeyValue());
        return converter;
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}
```

Finally, you can remove the `security.oauth2.client` properties from the `application.yaml` configuration file.

Once you have made the changes, run the authorization server again and re-run the above `curl` command.

There should be no change to how the `/oauth/token` endpoint responds to your requests. There is a difference though.
We have now moved the *registration* of clients into the code. Although this particular implementation is using an in-memory client store, which is statically initialised at boot time,
it would be trivial to replace this with a dynamic, database backed store (leaving this as a subject for a future post).

We have also changed the default permissions of the `/oath/token_key` endpoint to `permitAll()`, effectivelly making this endpoint public.
However, making a call to this endpoing (e.g. `curl http://localhost:8080/oauth/token_key`), returns something that looks like this:

```json
{
  "alg": "SHA256withRSA",
  "value": "otse1b"
}
```

This is definitely not a public key that a resource server would be able to use to verify digital signatures of JWT access tokens. What is going on here?

The issue is with how we have initialised the signing key of the `JwtAccessTokenConverter` (e.g. `converter.setSigningKey(properties.getJwt().getKeyValue())`).
By only setting the signing (and not the verifier) key, it defaulted the verifier key to a randomly generated string. This is not what we want.

We have two options. Either we configure a PEM encoded public verifier key in the application.yaml (just as we did with the signing key), or we use the signing key to derive a
`java.security.KeyPair` and pass that to the `JwtAccessTokenConverter` instance. As this is a more interesting approach, let's do that. Make the following changes to the
`AuthorizationServerConfigurer` class:

```java
@Bean
public JwtAccessTokenConverter accessTokenConverter() {
    var converter = new JwtAccessTokenConverter();
    converter.setKeyPair(getKeyPair());
    return converter;
}

private KeyPair getKeyPair() {
    try {
        var factory = KeyFactory.getInstance("RSA");
        var reader = new PemReader(new StringReader(properties.getJwt().getKeyValue()));
        var keyPair = (PEMKeyPair) new PEMParser(reader).readObject();
        var privateKeySpec = new PKCS8EncodedKeySpec(keyPair.getPrivateKeyInfo().getEncoded());
        var publicKeySpec = new X509EncodedKeySpec(keyPair.getPublicKeyInfo().getEncoded());
        var privateKey = factory.generatePrivate(privateKeySpec);
        var publicKey = factory.generatePublic(publicKeySpec);
        return new KeyPair(publicKey, privateKey);
    } catch (NoSuchAlgorithmException | InvalidKeySpecException | IOException e) {
        throw new RuntimeException("Cannot parse RSA private key");
    }
}
```

With these changes, the call to the `/oath/token_key` endpoint should return the following response:

```json
{
  "alg": "SHA256withRSA",
  "value":"-----BEGIN PUBLIC KEY-----\nMIIBIjANBgkq....2wIDAQAB\n-----END PUBLIC KEY-----"
}
```

This endpoint is now useful to resource servers that wish to dynamically load the public key of the authorization server to verify JWT access token signatures.

If you are familiar with the OpenID Connect (OIDC) specification, you may notice that this endpoint does not quite conform to the "Public Server JWK Set" API
(both the URI of the endpoint, as well as its payload). We will explore ways of fixing this in a future post.

However, for any Spring application that uses the `@EnableResourceServer` annotation, the `/oauth/token_key` endpoint should work as is provided you use the
`security.oauth2.resource.jwt.key-uri` property instead of the `security.oauth2.resource.jwk.key-set-uri`, which does expect a standards compliant response.

### Conclusion
This guide demonstrated how to implement a customer OAuth authorization server using Spring Boot 2 and Spring Security 5.

The complete, working solution is available in [GitHub][spring-boot-oauth2-authorization-server.git].

[spring-boot-oauth2-authorization-server.git]: https://github.com/academyhq/spring-boot-oauth2-authorization-server
