---
layout: post
title: Building reactive web applications using Spring WebFlux
date: 2019-07-18
tags: [spring framework, spring webflux, reactive, spring data, jpa]
---

In this guide, we will discuss how to build reactive web applications using [Reactive Streams](https://www.reactive-streams.org) API.
In Spring, the reactive-stack web framework is implemented in the form of a Spring WebFlux library.

Spring WebFlux provides two programming models for defining reactive applications, annotation-based and functional.

The annotation-based programming model abstracts the reactive nature of our application, making it simpler to transition from the Servlet API.

In this guide, we will explore the functional programming model.

The code for this guide is available in [GitHub][spring-webflux.git].

### Create a new project
Create a new Spring Boot project using Gradle (v5.5.x).

```bash
~$ mkdir spring-webflux && cd spring-webflux
~$ gradle init --project-name spring-webflux --type java-application --test-framework junit-jupiter --package spring.webflux.example --dsl groovy
```

Replace the contents of the `build.gradle` file with the following:

```groovy
plugins {
    id 'java'
    id 'idea'
    id 'org.springframework.boot' version '2.1.5.RELEASE'
    id 'io.spring.dependency-management' version '1.0.7.RELEASE'
}

repositories {
    jcenter()
}

dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-webflux'
    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
    implementation 'com.h2database:h2:1.4.199'

    testImplementation('org.springframework.boot:spring-boot-starter-test') {
        exclude group: 'junit', module: 'junit'
    }
    testImplementation 'org.junit.jupiter:junit-jupiter:5.5.0'
    testImplementation 'org.junit.platform:junit-platform-commons:1.5.0'
    testImplementation 'org.junit.platform:junit-platform-launcher:1.5.0'
    testImplementation 'io.projectreactor:reactor-test:3.2.10.RELEASE'
    testImplementation 'org.hamcrest:hamcrest:2.1'
}

sourceCompatibility = 11.0
targetCompatibility = 11.0

test {
    useJUnitPlatform()
}
```

### Spring Boot Application
Let's convert the vanila Java application auto-generated by the `gradle` script into a Spring Boot web application.
Replace the contents of the `App.java` class file with the following:

```java
package spring.webflux.example;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class App {

    public static void main(String[] args) {
        SpringApplication.run(App.class, args);
    }
}
```

Now, we have a functional web application.
By adding the `spring-boot-starter-webflux` to our classpath, instead of `spring-boot-starter-web`, we get an instance of the Netty server,
which supports asynchronous, non-blocking, event-based processing. Exactly what we need in a reactive application.

### Create microservice
For demonstration purposes, let's build a simple CRUD application, which allows callers to create, update and delete messages managed by our service.
We will expose these operations as a standard, REST API and use an in-memory database (e.g. H2) for persistence.

A basic `Message` entity class can be implemented as follows:

```java
package spring.webflux.example.message;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.validation.constraints.NotNull;

@Entity
public class Message {

    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private long id;

    @NotNull
    @Column
    private String text;

    private Message() {
        // default constructor required by Jackson to deserialize from JSON
    }

    private Message(long id, String text) {
        this.id = id;
        this.text = text;
    }

    public Message(String text) {
        this(0L, text);
    }

    public long getId() {
        return id;
    }

    public String getText() {
        return text;
    }

    public Message updateMessageText(String text) {
        return new Message(this.getId(), text);
    }
}
```

This is a simple POJO sprinkled with JPA annotations that will allow us to use an ORM library, such as Hibernate to persist `Message` objects to a relational database.
In this case, a H2 in-memory database.

The `updateMessageText` method is nothing more than a crude way to update message text in an immutable way.

Likewise, the `MessageRepository` interface, is a mechanism by which `spring-data-jpa` allows us to define database repositories without boilerplate code that normally goes along with it.

> IMPORTANT
>
> JDBC is inherently blocking and as such does not support reactive programming model.
> We will work around this limitation in this guide but will re-visit this in the next [post][spring-webflux-r2dbc.post].

```java
package spring.webflux.example.message;

import org.springframework.data.repository.CrudRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface MessageRepository extends CrudRepository<Message, Long> {
}
```

### Create HTTP Request Handler
We are used to handling requests in Spring applications using a controller class, normally annotated with `@Controller` or `@RestController`.
When following a functional approach, we need to define a handler class instead. We will then be able to map each method in the handler class to one (or more) API operations.

```java
package spring.webflux.example.message;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Component;
import org.springframework.web.reactive.function.server.ServerRequest;
import org.springframework.web.reactive.function.server.ServerResponse;
import reactor.core.publisher.Mono;

import java.net.URI;

@Component
public class MessageHandler {

    @Autowired
    private MessageRepository messageRepo;

    public Mono<ServerResponse> get(ServerRequest req) {
        var id = Long.valueOf(req.pathVariable("id"));
        return messageRepo.findById(id)
            .map(msg ->
                ServerResponse.ok()
                    .contentType(MediaType.APPLICATION_JSON)
                    .syncBody(msg)
            )
            .orElse(ServerResponse.notFound().build());
    }

    public Mono<ServerResponse> create(ServerRequest req) {
        var message = req.bodyToMono(Message.class);
        return message.map(messageRepo::save)
            .flatMap(msg ->
                ServerResponse.created(URI.create("/messages/" + msg.getId()))
                    .contentType(MediaType.APPLICATION_JSON)
                    .syncBody(msg)
            );
    }

    public Mono<ServerResponse> update(ServerRequest req) {
        var message = req.bodyToMono(Message.class);
        return message.map(messageRepo::save)
            .flatMap(msg ->
                ServerResponse.ok()
                    .contentType(MediaType.APPLICATION_JSON)
                    .syncBody(msg)
            );
    }

    public Mono<ServerResponse> delete(ServerRequest req) {
        var id = Long.valueOf(req.pathVariable("id"));
        try {
            messageRepo.deleteById(id);
        } catch (EmptyResultDataAccessException e) {
            // delete operation should be idempotent, so absorbing this exception
        }
        return ServerResponse.ok().build();
    }
}
```

The important aspect to note about the above class, is the use of reactive construct `Mono`, wrapping our responses.

A reactive application needs to be able to produce a stream of data that a consumer can "react" to.
When only a single result is expected (i.e. we need to produce a stream with a single element), then the `Mono` class can be used.

By making all methods in the above class return `Mono`, we are effectively making them all asynchronous.

*Note:* As was mentioned previously, our `MessageRepository` implementation does not support reactive programming due to its reliance on JDBC.
As such, we need to block execution within each method to handle database calls and produce server responses. We will address this limitation in the next [post][spring-webflux-r2dbc.post].

### Create a router
When we use annotation-based programming model, we rely on `@RequestMapping` or `@GetMapping`, etc., annotations to define our routing mappings.
In a functional programming model, we use APIs instead of annotations to do the same.
In the following example, we map the various handler methods we defined above to their corresponding routes.

```java
package spring.webflux.example.message;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.reactive.function.server.RouterFunction;
import org.springframework.web.reactive.function.server.ServerResponse;

import static org.springframework.http.MediaType.APPLICATION_JSON;
import static org.springframework.web.reactive.function.server.RequestPredicates.accept;
import static org.springframework.web.reactive.function.server.RouterFunctions.route;

@Configuration
public class MessageRouter {

    @Bean
    public RouterFunction<ServerResponse> routes(MessageHandler handler) {
        return route()
            .path("/messages", builder -> builder
                .GET("/{id}", handler::get)
                .POST("/", accept(APPLICATION_JSON), handler::create)
                .PUT("/{id}", accept(APPLICATION_JSON), handler::update)
                .DELETE("/{id}", accept(APPLICATION_JSON), handler::delete)
            ).build();
    }
}
```

### Testing
Testing the above application in a JUnit test is simple. The `spring-boot-starter-test` library provides various components that make this possible.

The `@SpringBootTest` annotation, allows us to start the application in a real server so that we can exercise each endpoint the same way a real client would.

In addition, `spring-boot-test-autoconfigure` will ensure that an instance of `WebTestClient` is available and can be injected into each test,
so that making HTTP calls and verifying responses is also simple.

```java
package spring.webflux.example.message;

import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.web.reactive.server.WebTestClient;

import static java.lang.String.format;
import static org.hamcrest.CoreMatchers.is;
import static org.hamcrest.MatcherAssert.assertThat;
import static org.springframework.boot.test.context.SpringBootTest.WebEnvironment.RANDOM_PORT;

@SpringBootTest(webEnvironment = RANDOM_PORT)
public class MessageEndpointIT {

    @Autowired
    private MessageRepository messageRepo;

    @Autowired
    private WebTestClient client;

    private Message message;

    @BeforeEach
    public void setUpDatabseWithDefaultMessage() {
        message = messageRepo.save(new Message("Hello World!"));
    }

    @AfterEach
    public void deleteMessagesFromDatabase() {
        messageRepo.deleteAll();
    }

    @Test
    public void testCreateMessage() {
        var message = new Message("Hello There!");
        client.post().uri("/messages")
                .syncBody(message)
                .exchange()
                .expectStatus().isCreated()
                .expectHeader().valueMatches("Location", "^/messages/\\d$")
                .expectBody()
                .jsonPath("id").isNumber()
                .jsonPath("text").isEqualTo(message.getText());
    }

    @Test
    public void testRetrieveMessage() {
        var uri = format("/messages/%d", message.getId());
        client.get().uri(uri)
                .exchange()
                .expectStatus().isOk()
                .expectBody()
                .jsonPath("id").isEqualTo(message.getId())
                .jsonPath("text").isEqualTo(message.getText());
    }

    @Test
    public void testRetrieveMessageThatDoesNotExist() {
        client.get().uri("/messages/100")
            .exchange()
            .expectStatus().isNotFound();
    }

    @Test
    public void testUpdateMessage() {
        var uri = format("/messages/%d", message.getId());
        client.put().uri(uri)
                .syncBody(message.updateMessageText("Text Changed!"))
                .exchange()
                .expectStatus().isOk()
                .expectBody()
                .jsonPath("id").isEqualTo(message.getId())
                .jsonPath("text").isEqualTo("Text Changed!");
    }

    @Test
    public void testDeleteMessage() {
        var uri = format("/messages/%d", message.getId());
        client.delete().uri(uri)
                .exchange()
                .expectStatus().isOk();
        assertThat(messageRepo.existsById(message.getId()), is(false));
    }
}
```

### Conclusion
In this guide, we presented how to build a reactive web application using Spring WebFlux.
We have also demonstrated how to unit test our application using `@SpringBootTest` and `WebTestClient`.

The complete, working solution is available in [GitHub][spring-webflux.git].

[spring-webflux.git]: https://github.com/academyhq/spring-webflux
[spring-webflux-r2dbc.post]: /2019/07/24/spring-webflux-r2dbc
