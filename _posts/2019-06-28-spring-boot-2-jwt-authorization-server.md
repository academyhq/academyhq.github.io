---
layout: post
title: (DRAFT) spring boot + spring security + jwt | authorization server
date: 2019-06-28
tags: [spring framework, spring boot, spring security, java, gradle, jwt, oauth]
---

This guide demonstrates how to build an OAuth 2 authorization server using Spring Boot 2 and Spring Security 5.
We will use JSON Web Token (JWT) standard to represent access tokens generated by this authorization server.
We shall make use of asymmetric key cryptography (specifically `RS256`) to digitally sign access tokens.

### Create a new project
Create a new Spring Boot project using Gradle.

```bash
> mkdir spring-boot-jwt-authorization-server && cd spring-boot-jwt-authorization-server
> gradle init --project-name spring-boot-jwt-authorization-server --type java-application --test-framework junit --package spring.boot.jwt.authorization.server --dsl groovy
```

Replace the contents of the `build.gradle` file with the following:

```groovy
plugins {
  id 'java'
  id 'idea'
  id 'org.springframework.boot' version '2.1.4.RELEASE'
  id 'io.spring.dependency-management' version '1.0.7.RELEASE'
}

repositories {
  jcenter()
}

dependencies {
  implementation 'org.springframework.boot:spring-boot-starter-web'
  implementation 'org.springframework.boot:spring-boot-starter-security'
  implementation 'org.springframework.security.oauth.boot:spring-security-oauth2-autoconfigure:2.1.6.RELEASE'
  implementation 'org.glassfish.jaxb:jaxb-runtime'

  testImplementation('org.springframework.boot:spring-boot-starter-test') {
      exclude group: 'junit', module: 'junit'
  }
  testImplementation 'org.springframework.security:spring-security-test'
  testImplementation 'org.hamcrest:hamcrest:2.1'
  testImplementation 'org.junit.jupiter:junit-jupiter:5.4.2'
  testImplementation 'org.junit.platform:junit-platform-launcher:1.4.1'
}

sourceCompatibility = 11.0
targetCompatibility = 11.0

test {
  useJUnitPlatform()
}
```

### Spring Boot Application
Let's convert the vanila Java application auto-generated by the `gradle` script into a Spring Boot web application.
Replace the contents of the `App.java` class file with the following:

```java
package spring.boot.jwt.authorization.server;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.security.oauth2.config.annotation.web.configuration.EnableAuthorizationServer;

@SpringBootApplication
@EnableAuthorizationServer
public class App {
    public static void main(String[] args) {
        SpringApplication.run(App.class, args);
    }
}
```

We declare the above class to be both a Spring Boot application (using the `@SpringBootApplication` annotation),
as well as an OAuth authorization server (using the `@EnableAuthorizationServer` annotation).

### Configure Authorization Server
Since we want our authorization server to create JWT tokens signed using `RS256` algorithm, we need to generate a private, signing key and configure our application.
You can use OpenSSL to generate the signing and verifier keys. For example, to generate a 2048 bit RSA key pair do the following:

```bash
> openssl genrsa -out signing-key.pem 2048
> openssl rsa -in signing-key.pem -pubout -out verifier-key.pem
```

Copy the contents of the `signing-key.pem` file into the `src/main/resources/application.yaml` file using the `security.oauth2.authorization.jwt.key-value` property.

You will also have to configure a client. This is the application that will be making calls to the resource server on behalf of your users.
At the minimum, this client needs to be issued with a client identifier and an authentication secret. 
The client application will use these credentials to access protected resources of the authorization server.

```yaml
security:
  oauth2:
    client:
      client-id: client
      client-secret: password
    authorization:
      jwt:
        key-value: |
          -----BEGIN RSA PRIVATE KEY-----
          MIIEowIBAAKCAQEA1vHuOHqm8nI8A1EulAyABIr1JyIxy2eGKVpbDD8PX2Az0MHU
          auIGc1fKuXtpy/QxAun6DEP1Rcf91i4AhnWXaaGqKmVvepHc6g8DWGaS+2xwiyh2
          iidSLL2jdJPjFe6w7sH/E7s/TfA+vuT2HQqUgGpqoJI1Bhinmf0PPiHJ8VeD0rn1
          DK7dkc99m6YyEiHWXMHbXPUt4M+XDvx+GGyvVJy2RNIcUBf3rUfn64fFWKPxoC64
          dVmC+9KTXY1JiCwKCqns2LQg0aAQUqdb8Q6PDzqN69TbTloSfgj3CGHhAfK7tuJb
          SF8xVBu3H3dhS3HC1y0dZVMMr/6aPNdwUOo/2wIDAQABAoIBAGQ0y6NHAve6a+H8
          AeQBY9k6UwoYdfBm5fP3bMTrzSXguqdTBc2CbBFv11HbiDoOMJ80J196eyk6EEu+
          jH4i6iDTvnofafZRdBUmRJ/8yf8u0dT+Wy0TIcs76a0amN6Lta7JgDpZrCyQmR/z
          rA1j9lFbyzPqlY+vBMvUXzvPEs9Q66mwfdMyaP6AJGStnv+5T7LTAN3oYqgy2oJk
          CITOS5hiUt7Hxv60Nc0DCqd0pLQd3r04MHX56WJGPI42eGpfv7bZe1nU20l4tEag
          Y+8uiJf1mGpxFi4UdHQiLEIyY4+poZbSAK35DiT+FKToidziciknULY0FvAGuwdj
          lPI6xyECgYEA6/VkODPiyzIHlnbVdh5Yu+8O89w9T8+zMYJcNBMsXNYUcnSMUqvz
          nZXanx/8GAsn5wE0ajI3bXcgV0ZNr3Ni5/0vBbb1D1oNcjIhoKf6lRd5KosfkpP6
          imNxee+8RGZjRzVklvTZnyg+YsVqPB7+4i1q4gHCzeDV8w8LUhssl+sCgYEA6TOg
          swEY/QI85ewIFFRxFoGNCMr4Q0dikn/+no5wtPlVeFCU1f75ypWjqoWwOWy7o28v
          aetnMs0NElXHotrtmOCAJ5zynTc5FUN7XLmYGLbTbL67VBR7lGYuR7YY8vfnBUwp
          wYtvrzIFasg5R1j4to3g0OfeIDmurD0eAIRJa9ECgYBn9SOEh4eiUpZ5Oj3t3ozl
          r/t8gUoaAb5HT9Hjt5bSCBfWHXc9bTjV8xHxDZx502BvLF61cw5skhGTogvUAxhO
          cYPoFqV9cAWAjIm4SInkagUeM1FjuQKnOgzi1jayRBH1a5a304SV1Js31RZrCpTt
          fWkbzf7PygE5JyWrtQE+pQKBgQCZaO45c+plXtiDBLAX96jhfl4yP5vsXoSZDXyJ
          //hjBXdVi+Utlevrel9NqV7RmBckH9uYGVUtVTlZK3cGSnFtVZrY9GWiSRbTRy5b
          RHirIXKaoiqH2GWnrUSaxk9JXw3qLT125myVWxm3MnqD1iLfrRwNMcutdWTUR+x5
          uIy4UQKBgDrmpCyYm1lU7tG+7k/FUlMcxw6IGJnWX4Gg9lkfFrVB2PU0f49RvB+f
          0P7RRPywzWxsLfqHRQ3UDhfKow5H0n34SaXjqjp6aB9y2po7nf+B7kP0w0m80pkn
          6dbbE+dxhvJPTcdO3mGTf8/Rn2qCKbiHUbHfXROb5yn3eiUXFFkY
          -----END RSA PRIVATE KEY-----
```

### Testing
Annotating your application with `@EnableAuthorizationServer` creates several OAuth endpoints that can be used to authenticate users and obtain & verify access tokens.
For the purpose of this guide, we will only use the `/oauth/token` endpoint to get an access token using `grant_type=client_credentials`.

```java
package spring.boot.jwt.authorization.server;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.web.client.TestRestTemplate;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpStatus;
import org.springframework.security.jwt.JwtHelper;
import org.springframework.security.jwt.crypto.sign.RsaVerifier;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.test.context.junit.jupiter.SpringExtension;
import org.springframework.util.LinkedMultiValueMap;

import java.util.Map;

import static org.hamcrest.CoreMatchers.is;
import static org.hamcrest.MatcherAssert.assertThat;
import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;
import static org.springframework.boot.test.context.SpringBootTest.WebEnvironment.RANDOM_PORT;

@ActiveProfiles("test")
@ExtendWith(SpringExtension.class)
@SpringBootTest(webEnvironment = RANDOM_PORT)
public class ClientAuthenticationIT {

    @Value("${jwt.verifier.key}")
    private String verifierKey;

    @Autowired
    private TestRestTemplate client;

    @Test
    public void testFailAuthIfNoClientCredentialsProvided() {
        var response = client.postForEntity("/oauth/token", null,  Void.class);
        assertThat(response.getStatusCode(), is(HttpStatus.UNAUTHORIZED));
    }

    @Test
    public void testSuccessfulAuthReturnsAccessToken() {
        var data = new LinkedMultiValueMap<String, String>();
        data.add("grant_type", "client_credentials");
        data.add("scope", "any");

        var entity = new HttpEntity<>(data, null);

        var response = client.withBasicAuth("client", "password")
                .postForEntity("/oauth/token", entity, Map.class);

        assertThat(response.getStatusCode(), is(HttpStatus.OK));

        var jwt = (String) response.getBody().get("access_token");
        assertDoesNotThrow(() -> JwtHelper.decodeAndVerify(jwt, new RsaVerifier(verifierKey)));
    }
}
```

The above test class uses a verifier (public) key to verify JWT access token signatures.
It is wired into the test class from the `src/test/resources/application-test.yaml`.
See the OpenSSL commands describes above for more information on how to generate the private and public keys.

```yaml
jwt.verifier.key: |
  -----BEGIN PUBLIC KEY-----
  MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA1vHuOHqm8nI8A1EulAyA
  BIr1JyIxy2eGKVpbDD8PX2Az0MHUauIGc1fKuXtpy/QxAun6DEP1Rcf91i4AhnWX
  aaGqKmVvepHc6g8DWGaS+2xwiyh2iidSLL2jdJPjFe6w7sH/E7s/TfA+vuT2HQqU
  gGpqoJI1Bhinmf0PPiHJ8VeD0rn1DK7dkc99m6YyEiHWXMHbXPUt4M+XDvx+GGyv
  VJy2RNIcUBf3rUfn64fFWKPxoC64dVmC+9KTXY1JiCwKCqns2LQg0aAQUqdb8Q6P
  DzqN69TbTloSfgj3CGHhAfK7tuJbSF8xVBu3H3dhS3HC1y0dZVMMr/6aPNdwUOo/
  2wIDAQAB
  -----END PUBLIC KEY-----
```

Run the test on the command line:

```bash
> ./gradew test
```

### Running the application

Start your Spring Boot application via this gradle command:

```bash
> ./gradlew bootRun
```

Once the application starts, we can test the `/oauth/token` endpoint using the `curl` command, e.g.


```bash
> curl -X POST client:password@localhost:8080/oauth/token -dgrant_type=client_credentials -dscope=any
```

The response should look something like this:

```json
{
  "access_token": "JWT ACCESS TOKEN GOES HERE",
  "token_type": "bearer",
  "expires_in": 43199,
  "scope": "any",
  "jti": "d3faa1c7-9c8a-462d-9b1a-35157f2f1da3"
}
```

### Conclusion
This guide demonstrated how to implement a customer OAuth authorization server using Spring Boot 2 and Spring Security 5.
